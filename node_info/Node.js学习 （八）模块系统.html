<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Node.js学习 （八）模块系统</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
<h2 style="text-align: center">Node.js学习 （八）模块系统</h2>
  <div class="stackedit__html"><h5><a id="_0"></a>导入模块</h5>
<blockquote>
<p>默认得到的是对象, 使用对象中的成员必须 <code>.</code> 点儿某个成员来访问</p>
</blockquote>
<pre><code class="prism language-javascript"><span class="token comment">//在没有下面导出的模块是不能直接require模块的</span>
<span class="token keyword">var</span> fooExports <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./foo'</span><span class="token punctuation">)</span>
<span class="token comment">// ReferenceError: foo is not defined</span>
<span class="token comment">// console.log(foo)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fooExports<span class="token punctuation">)</span>
</code></pre>
<h5><a id="_9"></a>导出模块</h5>
<blockquote>
<p>如果一个模块需要直接导出某个成员，而非挂载的方式,必须使用下<code>module.exports= 值或者对象</code></p>
</blockquote>
<pre><code class="prism language-javascript"><span class="token comment">//foo.js</span>
<span class="token comment">// 这种方式不行。</span>
<span class="token comment">// exports = add</span>

<span class="token comment">//1.到出数据 </span>
 module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">'hello'</span>
<span class="token comment">//2.导出方法,会覆盖上面的 hello 值</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

	
<span class="token comment">//main.js</span>
<span class="token keyword">var</span> fooExports <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./foo'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fooExports<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//输出  ：hello</span>
 
</code></pre>
<p>原理：</p>
<ol>
<li>在 Node 中，每个模块内部都有一个自己的 <code>module</code> 对象, 该 <code>module</code> 对象中，有一个成员叫：<code>exports</code> 也是一个对象</li>
</ol>
<pre><code class="prism language-javascript"><span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
   exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre>
<ol start="2">
<li>每次导出接口成员的时候都通过 <code>module.exports.xxx = xxx</code> 的方式很麻烦，点儿的太多了, 所以，Node 为了简化你的操作，专门提供了一个变量：<code>var exports = module.exports</code></li>
</ol>
<p>也就是说在底层模块中还有这么一句代码</p>
<pre><code class="prism language-javascript">  <span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports
</code></pre>
<ol start="3">
<li>我们可以简写<code>exports.属性='值'</code>  其实就是 <code>module.exports.属性='值'</code> 。那么我们如果直接<code>exports='值'</code>,就相当于重新给<code>exports</code> 赋值。那么应用的就不是 <code>module.exports</code>的导出方式。</li>
</ol>
<pre><code class="prism language-javascript"><span class="token comment">//这种操作是错误的</span>
exports <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//这种正确</span>
exports<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span>

<span class="token comment">//给 exports 赋值会断开和 module.exports 之间的引用。同理，给 module.exports 重新赋值也会断开</span>
<span class="token comment">// 这里导致 exports !== module.exports</span>
 module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
   foo<span class="token punctuation">:</span> <span class="token string">'bar'</span>
 <span class="token punctuation">}</span>

<span class="token comment">// 但是这里又重新建立两者的引用关系</span>
exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports
exports<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'hello'</span>
</code></pre>
<p>结论：</p>
<blockquote>
<p>导出多个成员：<code>exports.xxx = xxx</code> 或者 <code>module.exports = {}</code><br>
导出单个成员<code>必须</code>为：<code>module.exports={}</code><br>
<code>require</code>文件不会重复加载, 但是会得到导出的文件内部的对象</p>
</blockquote>
<h5><a id="require_64"></a>require加载规则</h5>
<ol>
<li>核心模块<br>
直接引入模块名</li>
</ol>
<pre><code class="prism language-javascript"><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol start="2">
<li>第三方模块<br>
直接引入模块名</li>
</ol>
<pre><code class="prism language-javascript"><span class="token keyword">var</span> template <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'art-template'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol start="3">
<li>自定义模块<br>
引入路径</li>
</ol>
<blockquote>
<p>路径形式的模块：<br>
<code>./</code> 当前目录，不可省略<br>
<code>../</code>上一级目录，不可省略<br>
<code>/xxx</code> 几乎不用<br>
<code>d:/a/foo.js</code> 几乎不用<br>
<code>/</code> 在这里表示的是当前文件模块所属磁盘根路径<br>
<code>.js</code> 后缀名可以省略</p>
</blockquote>
<pre><code class="prism language-javascript"><span class="token keyword">var</span> myModule <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./myModule'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<ol start="4">
<li>如何把自定义模块当做第三方模块加载</li>
</ol>
<blockquote>
<p>前提不能与核心模块和第三方模块重名</p>
</blockquote>
<p>比如定义一个my-module</p>
<blockquote>
<p><code>node_modules</code>-&gt;<code>node_modules/my-module</code>-&gt;<code>node_modules/my-module/package.json</code> -&gt;<code>first.js</code></p>
</blockquote>
<pre><code>没有`main`  就直接定义一个`index.js`
</code></pre>
<pre><code class="prism language-cmd">{
	main:'first.js'
}
</code></pre>
<pre><code class="prism language-javascript">module<span class="token punctuation">.</span><span class="token function-variable function">exports</span><span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'这就是我导出的内容'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<blockquote>
<p><code>node_modules/my-module/package.json</code> 文件中的 <code>main</code> 属性,  <code>main</code> 属性中就记录了 my-module 的入口模块, 这样就可以使用第三方包的导入方式直接无路径导入<br>
实际上最终加载的还是文件&gt;如果 package.json 文件不存在或者 main 指定的入口模块是也没有<br>
则 node 会自动找该目录下的 index.js<br>
也就是说 index.js 会作为一个默认备选项</p>
</blockquote>
<p>导入</p>
<pre><code class="prism language-javascript"><span class="token keyword">var</span> my<span class="token operator">-</span>module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'my-module'</span><span class="token punctuation">)</span>
</code></pre>
</div>
</body>

</html>
